-- Midpoint circle algorithm
-- Stolen shamelessly from Wikipedia's example implementation
local function mp_circle(layer, radius, x0, y0)
  if (radius == 0) then
    layer[x0][y0] = "X"
    return
  end

  local f = 1 - radius;
  local ddF_x = 1;
  local ddF_y = -2 * radius;
  local x = 0;
  local y = radius;
 
  layer[x0][y0 + radius] = "X"
  layer[x0][y0 - radius] = "X"
  layer[x0 + radius][y0] = "X"
  layer[x0 - radius][y0] = "X"
 
  while (x < y) do
    if (f >= 0) then
      y = y - 1
      ddF_y = ddF_y + 2
      f = f + ddF_y
    end
    x = x + 1
    ddF_x = ddF_x + 2
    f = f + ddF_x
    layer[x0 + x][y0 + y] = "X"
    layer[x0 - x][y0 + y] = "X"
    layer[x0 + x][y0 - y] = "X"
    layer[x0 - x][y0 - y] = "X"
    layer[x0 + y][y0 + x] = "X"
    layer[x0 - y][y0 + x] = "X"
    layer[x0 + y][y0 - x] = "X"
    layer[x0 - y][y0 - x] = "X"
  end
end

local tArgs={...}
local diameter = tonumber(tArgs[1])
--local perc = tonumber(tArgs[2] or 1)

if (diameter%2 ~= 1) then
  -- FIXME This should be easy to work around
  error("Requires an odd diameter")
end
local origin = math.ceil(diameter/2)

c_rads = {}
base = pattern.init_2d_pattern(diameter)
mp_circle(base, origin-1, origin, origin)
for y=1,origin do
  min_x = diameter
  max_x = 0
  for x=0,diameter do
    if base[y][x] == "X" then
      if x < min_x then min_x = x end
      if x > max_x then max_x = x end
    end
  end
  table.insert(c_rads, math.floor((max_x - min_x)/2))
end

-- Build a circle outline for each layer from the bottom to the middle
p = pattern.init_3d_pattern(diameter)
for i,r in ipairs(c_rads) do
  mp_circle(p[i], r, origin, origin)
end

-- Fill in the bottom
for y=1,p["size"] do
  min_x = p["size"]
  max_x = 0
  x_count = 0
  for x=1,p["size"] do
    if (p[2][y][x] == "X") then
      x_count = x_count + 1
      if (x > max_x) then max_x = x end
      if (x < min_x) then min_x = x end
    end
  end
  if (x_count == 2) then
    for x=min_x+1,max_x-1 do
      p[1][y][x] = "X"
    end
  end
end

-- Fill in gaps between layers
for h=2,#c_rads do
  ref_h = h + 1
  for y=2,p["size"]-1 do
    for x=2,p["size"]-1 do
      if (
        p[h][y][x] ~= "X" and
        (p[h][y-1][x] == "X" or p[ref_h][y-1][x] == "X") and
        (p[h][y+1][x] == "X" or p[ref_h][y+1][x] == "X") and
        (p[h][y][x-1] == "X" or p[ref_h][y][x-1] == "X") and
        (p[h][y][x+1] == "X" or p[ref_h][y][x+1] == "X")
      ) then
        p[h][y][x] = "X"
      end
    end
  end
end

-- Copy and flip the bottom of the sphere to the top
for h=#c_rads+2,p["size"] do
  p[h] = p[p["size"]-h+1]
end
p[#c_rads+1] = p[#c_rads]

counters = pattern.build(p, 0, origin, origin)
for k,v in pairs(counters) do
  print(k .. ": " .. v)
end
